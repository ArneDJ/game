#version 430 core

// input
layout (rgba32f, binding = 0) uniform image2D EROSIONMAP_READ;
layout (rgba32f, binding = 1) uniform image2D FLUXMAP_READ;
// output
layout (rgba32f, binding = 2) uniform image2D EROSIONMAP_WRITE; // to update the water
layout (rgba32f, binding = 3) uniform image2D VELOCITYMAP_WRITE;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform float TIME;
uniform int WIDTH;
uniform int HEIGHT;

void main(void)
{
	float pipelen = 1.0; 

	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec4 topflux = imageLoad(FLUXMAP_READ, uv + ivec2(0, 1));
	vec4 rightflux = imageLoad(FLUXMAP_READ, uv + ivec2(1, 0));
	vec4 bottomflux = imageLoad(FLUXMAP_READ, uv + ivec2(0, -1));
	vec4 leftflux = imageLoad(FLUXMAP_READ, uv + ivec2(-1, 0));

	vec4 erosion = imageLoad(EROSIONMAP_READ, uv);
	vec4 flux = imageLoad(FLUXMAP_READ, uv);

	//out flow flux
	float ftopout = flux.x;
	float frightout = flux.y;
	float fbottomout = flux.z;
	float fleftout = flux.w;

	vec4 outputflux = flux;
	vec4 inputflux = vec4(topflux.z,rightflux.w,bottomflux.x,leftflux.y);

	// The water height in each should increase by the total amount of incoming flow and decrease by the amount of total outgoing flow.
	float fout = ftopout+frightout+fbottomout+fleftout;
	// incoming flow is the outgoing flow from neighbor cells in opposite directions
	//float fin = inputflux.x + inputflux.y + inputflux.z + inputflux.w;
	float fin = topflux.z+rightflux.w+bottomflux.x+leftflux.y;

	// The total volume change of the column is:
	// new water height
	float deltavol = TIME*(fin-fout)/(pipelen*pipelen);

	// Finally apply the volume change to the water column, since we store the height and not the volume we need to divide by cell area:
	float waterheight = erosion.g + deltavol;

	float d1 = erosion.g + erosion.b;
	float d2 = d1 + deltavol;
	float da = (d1 + d2)/2.0f;

	vec2 veloci = vec2(inputflux.w-outputflux.w+outputflux.y-inputflux.y,inputflux.z-outputflux.z+outputflux.x-inputflux.x)/2.0;

	if (da <= 1e-4) {
		veloci = vec2(0.0);
	} else{
		veloci = veloci/(da * pipelen);
	}

	if (uv.x >= WIDTH-1 || uv.x <= 0) {
		veloci = vec2(0.0, 0.0);
		deltavol = 0.0;
	}
	if (uv.y >= HEIGHT-1 || uv.y <= 0) {
		veloci = vec2(0.0, 0.0);
		deltavol = 0.0;
	}

//vec4 color = vec4(erosion.r, max(erosion.g + deltavol, 0.0), erosion.b, erosion.a);
	vec4 color = vec4(erosion.r, max(waterheight, 0.0), erosion.b, erosion.a);

	imageStore(VELOCITYMAP_WRITE, uv, vec4(veloci, 0.0, 0.0));
	imageStore(EROSIONMAP_WRITE, uv, color);
}

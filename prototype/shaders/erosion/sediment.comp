#version 430 core

// input
layout (rgba32f, binding = 0) uniform image2D EROSIONMAP_READ;
layout (rgba32f, binding = 1) uniform image2D VELOCITYMAP_READ;
// output
layout (rgba32f, binding = 2) uniform image2D EROSIONMAP_WRITE; 
layout (rgba32f, binding = 3) uniform image2D VELOCITYMAP_WRITE;
layout (rgba32f, binding = 4) uniform image2D NORMALMAP;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// TODO pass as arguments
/*
vec3 sample_normal(ivec2 uv)
{
	float height = imageLoad(EROSIONMAP_READ, uv).r;

	float top = imageLoad(EROSIONMAP_READ, uv + ivec2(0, 1)).r;
	float right = imageLoad(EROSIONMAP_READ, uv + ivec2(1, 0)).r;
	float bottom = imageLoad(EROSIONMAP_READ, uv + ivec2(0, -1)).r;
	float left = imageLoad(EROSIONMAP_READ, uv + ivec2(-1, 0)).r;

	vec3 nor = vec3(left - right, 2.0, top - bottom);
	nor = normalize(nor);

	return nor;
}
*/

vec3 sample_normal(ivec2 uv) 
{
	int x = uv.x;
	int y = uv.y;

	float T = imageLoad(EROSIONMAP_READ, ivec2(x, y + 1)).r;
	float TR = imageLoad(EROSIONMAP_READ, ivec2(x + 1, y + 1)).r;
	float TL = imageLoad(EROSIONMAP_READ, ivec2(x - 1, y + 1)).r;
	float B = imageLoad(EROSIONMAP_READ, ivec2(x, y - 1)).r;
	float BR = imageLoad(EROSIONMAP_READ, ivec2(x + 1, y - 1)).r;
	float BL = imageLoad(EROSIONMAP_READ, ivec2(x - 1, y - 1)).r;
	float R = imageLoad(EROSIONMAP_READ, ivec2(x + 1, y)).r;
	float L = imageLoad(EROSIONMAP_READ, ivec2(x - 1, y)).r;

	// sobel filter
	const float X = (TR + 2.f * R + BR) - (TL + 2.f * L + BL);
	const float Z = (BL + 2.f * B + BR) - (TL + 2.f * T + TR);
	const float Y = 1.f / 32.f;

	vec3 normal = vec3(-X, Y, Z);
	normal = normalize(normal);

	return normal;
}

void main(void)
{
	float pipelen = 1.0; 

	const float Kc = 0.8; // sediment capacity factor
	const float Ks = 0.025; // dissolving constant
	const float Kd = 0.004; // deposition constant
	float alpha = 20.0;

	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec3 nor = sample_normal(uv);
//float slopeangle = abs(nor.y) / length(nor);
	float slopeangle = abs(sqrt(1.0 - nor.y*nor.y));

	vec2 topvel = imageLoad(VELOCITYMAP_READ, uv + ivec2(0, 1)).xy;
	vec2 rightvel = imageLoad(VELOCITYMAP_READ, uv + ivec2(1, 0)).xy;
	vec2 bottomvel = imageLoad(VELOCITYMAP_READ, uv + ivec2(0, -1)).xy;
	vec2 leftvel = imageLoad(VELOCITYMAP_READ, uv + ivec2(-1, 0)).xy;

	vec2 curvel = imageLoad(VELOCITYMAP_READ, uv).xy;

	float sum = length(topvel) + length(rightvel) + length(bottomvel) + length(leftvel);

	vec2 newvel = (topvel + rightvel + bottomvel + leftvel + alpha * curvel)/(4.0 + alpha);
	newvel = curvel;

	vec4 erosion = imageLoad(EROSIONMAP_READ, uv);
	float sediment = erosion.b;

	float speed = length(newvel);
	float slope = max(0.01f, abs(slopeangle));
	float sedicap = Kc*slope*speed;
//float sedicap = Kc*sin(slopeangle)*speed;

	float lmax = 0.0f;
	float maxdepth = 0.1;
	if (erosion.y > maxdepth){ // max river bed depth
		lmax = 0.0f;
	} else {
		lmax = ((maxdepth - erosion.y)/maxdepth);
	}

	float height = erosion.r;
	float cursedi = erosion.b;
	float outsedi = erosion.b;

	float water = erosion.g;

	if (sedicap > cursedi) {
		float changesedi = (sedicap-cursedi)*Ks;
		height = height - changesedi;
		outsedi = outsedi + changesedi;
	} else {
		float changesedi = (cursedi-sedicap)*Kd;
		height = height + changesedi;
		outsedi = outsedi - changesedi;
	}

	vec4 color = erosion;
	// update height and sediment
	height = clamp(height, 0.0, 1.0);
//color.r = height;
	color.b = outsedi; // TODO sediment seems to be very low

	imageStore(EROSIONMAP_WRITE, uv, color);
	imageStore(VELOCITYMAP_WRITE, uv, vec4(newvel, 0.0, 0.0));
	imageStore(NORMALMAP, uv, vec4(nor, 1.0));
}
